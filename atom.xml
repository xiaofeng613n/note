<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>峰&#39;s Harbor</title>
  
  <subtitle>It is never too late to learn.</subtitle>
  <link href="/note.github.io/atom.xml" rel="self"/>
  
  <link href="https://xiaofeng613n.github.io/"/>
  <updated>2018-05-20T08:51:53.552Z</updated>
  <id>https://xiaofeng613n.github.io/</id>
  
  <author>
    <name>xiaofeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flume总结</title>
    <link href="https://xiaofeng613n.github.io/2018/06/30/20180630flume%E6%80%BB%E7%BB%93/"/>
    <id>https://xiaofeng613n.github.io/2018/06/30/20180630flume总结/</id>
    <published>2018-06-30T05:23:34.000Z</published>
    <updated>2018-05-20T08:51:53.552Z</updated>
    
    <content type="html"><![CDATA[<h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><ul><li><a href="https://flume.apache.org/documentation.html" target="_blank" rel="external">flume官网</a></li><li><a href="https://blog.csdn.net/manzhizhen/article/category/6427625" target="_blank" rel="external">大步流星的博客-flume</a></li><li><a href="http://blog.51cto.com/boylook/1298624" target="_blank" rel="external">Flume-ng FileChannel原理解析</a></li><li><a href="http://www.cnblogs.com/lxf20061900/category/565688.html" target="_blank" rel="external">随笔分类 - Flume-NG</a></li><li><a href="http://www.cnblogs.com/yurunmiao/p/5603097.html" target="_blank" rel="external">Flume FileChannel优化（扩展）实践指南</a>  </li><li><a href="http://jinnianshilongnian.iteye.com/category/350365" target="_blank" rel="external">Flume架构与源码分析</a></li><li><a href="https://tech.meituan.com/mt-log-system-arch.html" target="_blank" rel="external">基于Flume的美团日志收集系统(一)架构和设计</a></li><li><a href="https://github.com/javachen/mt-flume" target="_blank" rel="external">美团对 flume 的扩展和改进（代码）</a></li><li><a href="https://www.jianshu.com/p/9f6235cab8d8" target="_blank" rel="external">魅族大数据之流平台设计部署实践</a></li></ul><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>一个channel，多个sink   </p><ul><li><a href="https://issues.apache.org/jira/browse/FLUME-1435" target="_blank" rel="external">Proposal of Transactional Multiplex (fan out) Sink</a>   </li><li><a href="https://issues.apache.org/jira/browse/FLUME-1479" target="_blank" rel="external">Multiple Sinks can connect to single Channel</a>    </li><li><a href="http://blog.51cto.com/boylook/1308021" target="_blank" rel="external">Flume-ng:multi sink one channel两种配置方式的对比</a></li></ul><p>其他    </p><ul><li><a href="https://www.cnblogs.com/lxf20061900/p/4012847.html" target="_blank" rel="external">记Flume-NG一些注意事项</a></li><li>Spooling Directory Source虽然做不到实时，但是也可以通过日志文件的切分，做到准实时。</li><li>模块命名规则：所有的 Source 以 src 开头，所有的 Channel 以 ch 开头，所有的 Sink 以 sink 开头；</li></ul>]]></content>
    
    <summary type="html">
    
      参考：
 * flume官网
 * 大步流星的博客-flume
 * Flume-ng FileChannel原理解析
 * 随笔分类 - Flume-NG
 * Flume FileChannel优化（扩展）实践指南 
 * Flume架构与源码分析
 * 基于Flume的美团日志收集系统(一)架构和设计
 * 美团对 flume 的扩展和改进（代码）
 * 魅族大数据之流平台设计部署实践

问题
一个channel，多个sink 

 * Proposal of Transactional Multiplex (fan out) Sink 
 * Multiple Sinks can co
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="flume-ng" scheme="https://xiaofeng613n.github.io/tags/flume-ng/"/>
    
  </entry>
  
  <entry>
    <title>fFlume日志收集分层架构应用实践（转）</title>
    <link href="https://xiaofeng613n.github.io/2018/06/30/Flume%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
    <id>https://xiaofeng613n.github.io/2018/06/30/Flume日志收集分层架构（转）/</id>
    <published>2018-06-30T05:23:34.000Z</published>
    <updated>2018-05-17T13:13:15.295Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://shiyanjun.cn/archives/1497.html" target="_blank" rel="external">Flume日志收集分层架构应用实践</a></p><h5 id="为什么要对Flume日志收集系统进行分层设计"><a href="#为什么要对Flume日志收集系统进行分层设计" class="headerlink" title="为什么要对Flume日志收集系统进行分层设计"></a>为什么要对Flume日志收集系统进行分层设计</h5><p>基于Flume设计实现分层日志收集系统，到底有什么好处呢？我们可以先看一下，如果不分层，会带来哪些问题：</p><ul><li>如果需要通过Kafka去缓冲上游基于Flume收集而构建的日志流，对于数据平台内部服务器产生的数据还好，但是如果日志数据是跨业务组，甚至是跨部门，那么就需要将Kafka相关信息暴露给外部，这样对Kafka的访问便不是数据平台内部可控的</li><li>如果是外部日志进入平台内部HDFS，这样如果需要对Hadoop系统进行升级或例行维护，这种直连的方式会影响到上游部署Flume的日志流的始端日志收集服务</li><li>如果数据平台内部某些系统，如Kafka集群、HDFS集群所在节点的机房位置变更，数据迁移，会使得依赖日志数据的外部系统受到不同程度的影响，外部系统需要相关开发或运维人员参与进来</li><li>由于收集日志的数据源端可能是外部一些服务器（多个单个的节点），一些业务集群（相互协作的多节点组），也可能是内部一些提供收集服务的服务节点，这些所有的服务器上部署的Flume Agent都处于一层中，比较难于分组管理<br>由于所有数据源端Flume Agent收集的日志进入数据平台的时候，没有一个统一的类似总线的组件，很难因为某些业务扩展而独立地去升级数据平台内部的接收层服务节点，可能为了升级数据平台内部某个系统或服务而导致影响了其他的接收层服务节点</li></ul><p><img src="http://shiyanjuncn.b0.upaiyun.com/wp-content/uploads/2016/02/flume-with-layered-architecture.png" alt="image"><br>上图中，Flume日志收集系统采用两层架构设计：第一层（L1）是日志收集层，第二层（L2）是数据平台缓冲层（汇聚层）。通过这种方式，使得日志收集系统有如下特点：</p><ul><li>针对数据平台外部的业务系统，根据需要分析的数据业务类型进行分组，属于同一种类型的业务日志，在数据平台前端增加了一个Flume汇聚层节点组，该组节点只影响到它对应的L1层的业务数据</li><li>如果Hadoop集群、Kafka需要停机维护或升级，对外部L1层Flume Agent没有影响，只需要在L2层做好数据的接收与缓冲即可，待维护或升级结束，继续将L2层缓存的数据导入到数据存储系统</li><li>如果外部某个类型的业务日志数据节点需要扩容，直接在L1层将数据流指向数据平台内部与之相对应的L2层Flume Agent节点组即可，能够对外部因业务变化发生的新增日志收集需求，进行快速地响应和部署</li><li>对于数据平台内部，因为收集日志的节点非常可控，可以直接通过L1层Flume Agent使日志数据流入HDFS或Kafka，当然为了架构统一和管理，最好也是通过L2层Flume Agent节点组来汇聚/缓冲L1层Flume Agent收集的日志数据</li></ul><p>通过上面分析可见，分层无非是为了使的日志数据源节点的Flume Agent服务与数据平台的存储系统（Kafka/HDFS）进行解耦，同时能够更好地对同类型业务多节点的日志流进行一个聚合操作，并分离开独立管理。另外，可以根据实际业务需要，适当增加Flume系统分层，满足日志流数据的汇聚需要。</p>]]></content>
    
    <summary type="html">
    
      原文链接：Flume日志收集分层架构应用实践

为什么要对Flume日志收集系统进行分层设计
基于Flume设计实现分层日志收集系统，到底有什么好处呢？我们可以先看一下，如果不分层，会带来哪些问题：

 * 如果需要通过Kafka去缓冲上游基于Flume收集而构建的日志流，对于数据平台内部服务器产生的数据还好，但是如果日志数据是跨业务组，甚至是跨部门，那么就需要将Kafka相关信息暴露给外部，这样对Kafka的访问便不是数据平台内部可控的
 * 如果是外部日志进入平台内部HDFS，这样如果需要对Hadoop系统进行升级或例行维护，这种直连的方式会影响到上游部署Flume的日志流的始端日志收集服
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="flume-ng" scheme="https://xiaofeng613n.github.io/tags/flume-ng/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaofeng613n.github.io/2018/05/17/20180325flume%E6%BA%90%E7%A0%81-%E7%BB%84%E4%BB%B6FileChannel/"/>
    <id>https://xiaofeng613n.github.io/2018/05/17/20180325flume源码-组件FileChannel/</id>
    <published>2018-05-17T13:13:15.434Z</published>
    <updated>2018-05-17T13:13:15.644Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ChannelProcessor.processEvent(Event event)</div><div class="line">//拦截器过滤 </div><div class="line">interceptorChain.intercept(event);</div><div class="line">//ChannelSelector选取channel</div><div class="line">List&lt;Channel&gt; requiredChannels = selector.getRequiredChannels(event);</div><div class="line">//获得or创建事务</div><div class="line">Transaction tx = requiredChannels.getTransaction()</div><div class="line">createTransaction()</div><div class="line">trans = new FileBackedTransaction(log, TransactionIDOracle.next(),transactionCapacity, keepAlive,queueRemaining, getName(),fsyncPerTransaction, channelCounter);</div><div class="line"></div><div class="line">//4.开始事务</div><div class="line">tx.begin();</div><div class="line">BasicTransactionSemantics.doBegin //do nothing</div><div class="line">state = State.OPEN;</div><div class="line">//Event写入channel</div><div class="line">    reqChannel.put(event);</div><div class="line">BasicTransactionSemantics transaction = currentTransaction.get();  //ThreadLocal保存的事务</div><div class="line">transaction.put(event)       </div><div class="line">doPut(event) --&gt; FileChannel.FileBackedTransaction.doPut(Event evet)</div><div class="line">channelCounter.incrementEventPutAttemptCount(); -&gt; increment(COUNTER_EVENT_PUT_ATTEMPT);</div><div class="line">if(!queueRemaining.tryAcquire(keepAlive, TimeUnit.SECONDS))&#123;throw ...&#125;</div><div class="line">...</div><div class="line">//容量判断</div><div class="line">...</div><div class="line">log.lockShared();</div><div class="line">checkpointReadLock.lock();</div><div class="line">FlumeEventPointer ptr = log.put(transactionID, event);</div><div class="line">//Event包装成FlumeEvent</div><div class="line">FlumeEvent flumeEvent = new FlumeEvent(event.getHeaders(), event.getBody());</div><div class="line">//Put操作对象</div><div class="line">Put put = new Put(transactionID, WriteOrderOracle.next(), flumeEvent);</div><div class="line">ByteBuffer buffer = TransactionEventRecord.toByteBuffer(put);</div><div class="line">...</div><div class="line">//空间判断</div><div class="line">...</div><div class="line">//FlumeEventPointer对象包含：文件id + offset</div><div class="line">FlumeEventPointer ptr = logFiles.get(logFileIndex).put(buffer);</div><div class="line">...</div><div class="line">Pair&lt;Integer, Integer&gt; pair = write(buffer);</div><div class="line">...</div><div class="line">//recordLength = OP_RECORD + size + buffer ,put操作写入文件</div><div class="line">...</div><div class="line">int wrote = getFileChannel().write(toWrite);</div><div class="line">return Pair.of(getLogFileID(), offset); </div><div class="line">return new FlumeEventPointer(pair.getLeft(), pair.getRight());</div><div class="line">//FlumeEventPointer添加到FlumeEventQueue</div><div class="line">queue.addWithoutCommit(ptr, transactionID);</div><div class="line">inflightPuts.addEvent(transactionID, e.toLong());</div><div class="line">inflightEvents.put(transactionID, pointer);</div><div class="line">inflightFileIDs.put(transactionID,FlumeEventPointer.fromLong(pointer).getFileID());</div><div class="line">syncRequired = true;</div><div class="line">log.unlockShared();</div><div class="line">    //提交事务</div><div class="line">    tx.commit();</div><div class="line">doCommit(); //FileChannel.FileBackedTransaction.doCommit();</div><div class="line">int puts = putList.size();</div><div class="line">int takes = takeList.size();</div><div class="line"></div><div class="line">if( puts &gt; 0 )&#123;</div><div class="line">log.lockShared();</div><div class="line">checkpointReadLock.lock();</div><div class="line">log.commitPut(transactionID);</div><div class="line">commit(transactionID, TransactionEventRecord.Type.PUT.get());</div><div class="line">//Commit操作对象</div><div class="line">    Commit commit = new Commit(transactionID, WriteOrderOracle.next(), type);</div><div class="line">ByteBuffer buffer = TransactionEventRecord.toByteBuffer(commit);</div><div class="line">...</div><div class="line">//空间判断</div><div class="line">...</div><div class="line">LogFile.Writer logFileWriter = logFiles.get(logFileIndex);</div><div class="line">logFileWriter.commit(buffer);</div><div class="line">...</div><div class="line">write(buffer); //LogFile的write方法，同put对象写入文件</div><div class="line">dirty = true;</div><div class="line">lastCommitPosition = position();</div><div class="line">//Sync the underlying log file to disk.</div><div class="line">logFileWriter.sync();       </div><div class="line"> if (lastSyncPosition &lt; lastCommitPosition) &#123;</div><div class="line">getFileChannel().force(false);</div><div class="line">lastSyncPosition = position();</div><div class="line">syncCount++;</div><div class="line">dirty = false;</div><div class="line">  &#125;</div><div class="line">//Commit操作写入log后，FlumeEventPointer 从putList到queue</div><div class="line">synchronized (queue) &#123;</div><div class="line">while (!putList.isEmpty()) &#123;</div><div class="line">queue.addTail(putList.removeFirst())</div><div class="line">long value = e.toLong();</div><div class="line">backingStore.incrementFileID(e.getFileID());</div><div class="line">add(backingStore.getSize(), value);</div><div class="line">&#125;</div><div class="line">queue.completeTransaction(transactionID);</div><div class="line">inflightEvents.removeAll(transactionID);</div><div class="line">inflightFileIDs.removeAll(transactionID);</div><div class="line">syncRequired = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">log.unlockShared();</div><div class="line">&#125;</div><div class="line">else if ( takes &gt; 0) &#123;</div><div class="line">log.lockShared();</div><div class="line">log.commitTake(transactionID);</div><div class="line">commit(transactionID, TransactionEventRecord.Type.TAKE.get());</div><div class="line">//Commit操作对象 同put的commit对象</div><div class="line">...</div><div class="line">//</div><div class="line">queue.completeTransaction(transactionID);  </div><div class="line"></div><div class="line">log.unlockShared();</div><div class="line">queueRemaining.release(takes)</div><div class="line">&#125;</div><div class="line">putList.clear();</div><div class="line">takeList.clear();</div><div class="line">channelCounter.setChannelSize(queue.getSize());</div><div class="line">state = State.COMPLETED</div><div class="line">//关闭事务</div><div class="line">tx.close();</div><div class="line">state = State.CLOSED;</div><div class="line">doClose();  //nothing BasicTransactionSemantics</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">AbstractRpcSink.process()</div><div class="line">Status status = Status.READY;</div><div class="line">    Channel channel = getChannel();</div><div class="line">//获得or创建事务</div><div class="line">    Transaction transaction = channel.getTransaction();</div><div class="line">...</div><div class="line">//开启事务</div><div class="line">transaction.begin();</div><div class="line">doBegin  // do nothing  BasicTransactionSemantics.doBegin</div><div class="line">state = State.OPEN;</div><div class="line"></div><div class="line">List&lt;Event&gt; batch</div><div class="line">...</div><div class="line">//从channel中获得Event</div><div class="line">Event event = channel.take();</div><div class="line">transaction.take(); //BasicChannelSemantics</div><div class="line">doTake()  //FileChannel.FileBackedTransaction.doTake()</div><div class="line">channelCounter.incrementEventTakeAttemptCount();</div><div class="line">...</div><div class="line">log.lockShared()</div><div class="line"></div><div class="line">FlumeEventPointer ptr = queue.removeHead(transactionID);</div><div class="line">long value = remove(0, transactionID);</div><div class="line">inflightTakes.addEvent(transactionID, value);</div><div class="line">FlumeEventPointer ptr = FlumeEventPointer.fromLong(value);</div><div class="line">...</div><div class="line">//Take落盘，过程和Put大致相同</div><div class="line">log.take(transactionID, ptr);</div><div class="line">Take take = new Take(transactionID, WriteOrderOracle.next(),pointer.getOffset(),pointer.getFileID());</div><div class="line">ByteBuffer buffer = TransactionEventRecord.toByteBuffer(take);</div><div class="line">...</div><div class="line">//空间判断</div><div class="line">...</div><div class="line">logFiles.get(logFileIndex).take(buffer);</div><div class="line">Event event = log.get(ptr);</div><div class="line">log.unlockShared();</div><div class="line">...</div><div class="line">client.appendBatch(batch);</div><div class="line"></div><div class="line">//提交事务，见commit takes &gt; 0 的情况；</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Semaphore queueRemaining</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Put extends TransactionEventRecord</div><div class="line"></div><div class="line"></div><div class="line">class FlumeEventPointer &#123;</div><div class="line">  private final int fileID;</div><div class="line">  private final int offset;</div><div class="line">  </div><div class="line">  </div><div class="line">inflightEvents map transactionID -&gt; pointer</div><div class="line">inflightFileIDs map transactionID -&gt; fileID</div><div class="line"> </div><div class="line"> </div><div class="line">processEventBatch批量处理：</div><div class="line">1.event根据选择到的channel分组，(optChannels也是一样)</div><div class="line">Map&lt;Channel, List&lt;Event&gt;&gt; reqChannelQueue</div><div class="line">2.遍历reqChannel，遍历channel对应的List&lt;Event&gt;，put到channel</div><div class="line"></div><div class="line">与单Event的区别是:多个Event进行一次事务提交</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>flume源码-组件TaildirSource</title>
    <link href="https://xiaofeng613n.github.io/2018/04/08/20180408flume%E6%BA%90%E7%A0%81-%E7%BB%84%E4%BB%B6TaildirSource/"/>
    <id>https://xiaofeng613n.github.io/2018/04/08/20180408flume源码-组件TaildirSource/</id>
    <published>2018-04-08T05:23:34.000Z</published>
    <updated>2018-05-17T13:13:15.091Z</updated>
    
    <content type="html"><![CDATA[<h5 id="TaildirSource"><a href="#TaildirSource" class="headerlink" title="TaildirSource"></a>TaildirSource</h5><p>配置加载（configure方法）和资源关闭（stop方法）省略，主要是start和process方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    reader = <span class="keyword">new</span> ReliableTaildirEventReader.Builder()</div><div class="line">        ...</div><div class="line">          .build();</div><div class="line">    ...</div><div class="line">    idleFileChecker.scheduleWithFixedDelay(<span class="keyword">new</span> idleFileCheckerRunnable(),idleTimeout, checkIdleInterval, TimeUnit.MILLISECONDS);</div><div class="line">    ...</div><div class="line">    positionWriter.scheduleWithFixedDelay(<span class="keyword">new</span> PositionWriterRunnable(),writePosInitDelay, writePosInterval, TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.start();</div><div class="line">    sourceCounter.start();</div><div class="line">  &#125;</div></pre></td></tr></table></figure><ul><li>ReliableTaildirEventReader初始化；  </li><li>idleFileChecker定时执行idleFileCheckerRunnable:找到idleTimeout时间内没有更新过的历史文件；</li><li>positionWriter定时执行PositionWriterRunnable：existingInodes对象json格式化，写入文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">ReliableTaildirEventReader:</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> </span>&#123;</div><div class="line">    Status status = Status.READY;</div><div class="line">    ...</div><div class="line">    existingInodes.clear();</div><div class="line">    existingInodes.addAll(reader.updateTailFiles());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> inode : existingInodes) &#123;</div><div class="line">        TailFile tf = reader.getTailFiles().get(inode);</div><div class="line">        <span class="keyword">if</span> (tf.needTail()) &#123;</div><div class="line">          tailFileProcess(tf, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    closeTailFiles();</div><div class="line">    TimeUnit.MILLISECONDS.sleep(retryInterval);</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">--&gt;ReliableTaildirEventReader.tailFileProcess</div><div class="line">--&gt;ReliableTaildirEventReader.readEvents</div><div class="line">--&gt;TailFile.readEvents</div><div class="line">--&gt;TailFile.readEvent</div><div class="line">--&gt;TailFile.readLine</div></pre></td></tr></table></figure><ul><li>existingInodes.addAll(reader.updateTailFiles())<br>这里调用reader.updateTailFiles方法遍历目录、遍历文件，找到匹配的有更新的文件，tailFiles缓存TailFile，返回inode list；<br>该过程找到文件后，通过openFile(f, headers, inode, tf.getPos())方法包装成TailFile对象或者更新已有TailFile对象的信息updatePos(tf.getPath(), inode, 0)；<br>历史文件是否更新根据lastUpdated记录时间判断；<br>文件目录遍历的是List<taildirmatcher> taildirCache，该对象在ReliableTaildirEventReader创建的时候加载的，</taildirmatcher></li><li><p>tailFileProcess(TailFile tf, boolean backoffWithoutNL)<br>循环变量文件，按行批量读取日志；<br>TailFile内部有byte数组缓存数据；<br>主要的文件读取逻辑都在这一步里面，我能大概看懂，具体细节还要自己看代码</p></li><li><p>closeTailFiles()<br>从ReliableTaildirEventReader中找到idleInodes对应的TailFile执行关闭操作，这里的关闭操作会调用tailFileProcess，批量去读当前文件的行日志数据，然后关闭对应的RadomAccessFile</p></li></ul><p>实现PollableSource接口：在process方法中刷新existingInodes，根据目录时间判断<br>定时更新 idleInodes：通过文件更新时间判断；<br>定时刷新position文件：找打existingInodes 对应的TailFile；    </p>]]></content>
    
    <summary type="html">
    
      TaildirSource
配置加载（configure方法）和资源关闭（stop方法）省略，主要是start和process方法：

12345678910111213

public synchronized void start() {    ...    reader = new ReliableTaildirEventReader.Builder()        ...          .build();    ...    idleFileChecker.scheduleWithFixedDelay(new idleFileCheckerRunnable(),idleTimeo
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="flume-ng" scheme="https://xiaofeng613n.github.io/tags/flume-ng/"/>
    
  </entry>
  
  <entry>
    <title>flume源码-组件</title>
    <link href="https://xiaofeng613n.github.io/2018/03/25/20180325flume%E6%BA%90%E7%A0%81-%E7%BB%84%E4%BB%B6/"/>
    <id>https://xiaofeng613n.github.io/2018/03/25/20180325flume源码-组件/</id>
    <published>2018-03-25T05:23:34.000Z</published>
    <updated>2018-03-25T10:25:46.065Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Source-amp-SourceRunner-amp-ChannelProcessor-amp-ChannelSelector"><a href="#Source-amp-SourceRunner-amp-ChannelProcessor-amp-ChannelSelector" class="headerlink" title="Source&amp;SourceRunner&amp;ChannelProcessor&amp;ChannelSelector"></a>Source&amp;SourceRunner&amp;ChannelProcessor&amp;ChannelSelector</h5><p>flume的source分为两种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface PollableSource extends Source    //有process()方法来处理。系统自动调用process()</div><div class="line">public interface EventDrivenSource extends Source //没有process()方法，而是通过start()来执行向channel中发送送数据的操作。</div></pre></td></tr></table></figure></p><p>前面的flume启动过程已经分析过了，在调用AbstractConfigurationProvider.loadSources方法中，会根据配置的Source具体实现接口调用SourceRunner.forSource方法包装成对应的SourceRunner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static SourceRunner forSource(Source source) &#123;</div><div class="line">    SourceRunner runner = null;</div><div class="line"></div><div class="line">    if (source instanceof PollableSource) &#123;</div><div class="line">      runner = new PollableSourceRunner();</div><div class="line">      ((PollableSourceRunner) runner).setSource((PollableSource) source);</div><div class="line">    &#125; else if (source instanceof EventDrivenSource) &#123;</div><div class="line">      runner = new EventDrivenSourceRunner();</div><div class="line">      ((EventDrivenSourceRunner) runner).setSource((EventDrivenSource) source);</div><div class="line">    &#125; else &#123;</div><div class="line">      throw new IllegalArgumentException(&quot;No known runner type for source &quot;+ source);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return runner;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class EventDrivenSourceRunner extends SourceRunner &#123;</div><div class="line">  private LifecycleState lifecycleState;</div><div class="line">  ...</div><div class="line">  @Override</div><div class="line">  public void start() &#123;</div><div class="line">    Source source = getSource();</div><div class="line">    ChannelProcessor cp = source.getChannelProcessor();</div><div class="line">    cp.initialize();</div><div class="line">    source.start();</div><div class="line">    lifecycleState = LifecycleState.START;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>EventDrivenSourceRunner的start方法逻辑比较简单：</p><ol><li>初始化ChannelProcessor</li><li>执行source.start()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public class PollableSourceRunner extends SourceRunner &#123;</div><div class="line"></div><div class="line">  private static final Logger logger = LoggerFactory.getLogger(PollableSourceRunner.class);</div><div class="line"></div><div class="line">  private AtomicBoolean shouldStop;</div><div class="line"></div><div class="line">  private CounterGroup counterGroup;</div><div class="line">  private PollingRunner runner;</div><div class="line">  private Thread runnerThread;</div><div class="line">  private LifecycleState lifecycleState;</div><div class="line"></div><div class="line"> </div><div class="line">  @Override</div><div class="line">  public void start() &#123;</div><div class="line">    PollableSource source = (PollableSource) getSource();</div><div class="line">    ChannelProcessor cp = source.getChannelProcessor();</div><div class="line">    cp.initialize();</div><div class="line">    source.start();</div><div class="line"></div><div class="line">    runner = new PollingRunner();</div><div class="line"></div><div class="line">    runner.source = source;</div><div class="line">    runner.counterGroup = counterGroup;</div><div class="line">    runner.shouldStop = shouldStop;</div><div class="line"></div><div class="line">    runnerThread = new Thread(runner);</div><div class="line">    runnerThread.setName(getClass().getSimpleName() + &quot;-&quot; + </div><div class="line">        source.getClass().getSimpleName() + &quot;-&quot; + source.getName());</div><div class="line">    runnerThread.start();</div><div class="line"></div><div class="line">    lifecycleState = LifecycleState.START;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static class PollingRunner implements Runnable &#123;</div><div class="line"></div><div class="line">    private PollableSource source;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      ...</div><div class="line">      while (!shouldStop.get()) &#123;</div><div class="line">        counterGroup.incrementAndGet(&quot;runner.polls&quot;);</div><div class="line">        ...</div><div class="line">        if (source.process().equals(PollableSource.Status.BACKOFF)) &#123; //调用process方法</div><div class="line">            counterGroup.incrementAndGet(&quot;runner.backoffs&quot;);</div><div class="line"></div><div class="line">            Thread.sleep(Math.min(</div><div class="line">                counterGroup.incrementAndGet(&quot;runner.backoffs.consecutive&quot;)</div><div class="line">                * source.getBackOffSleepIncrement(), source.getMaxBackOffSleepInterval()));</div><div class="line">          &#125; else &#123;</div><div class="line">            counterGroup.set(&quot;runner.backoffs.consecutive&quot;, 0L);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>PollableSourceRunner的start</p><ol><li>初始化ChannelProcessor </li><li>启动一个线程runnerThread，循环调用source（PollableSource）的process方法（如果失败等待超时时间之后重试）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ChannelProcessor</div><div class="line">    MultiplexingChannelSelector  // 可以选择该发往哪些channel</div><div class="line">    ReplicatingChannelSelector // allows the event to be placed in all the channels</div></pre></td></tr></table></figure><h5 id="Sink-amp-SinkRunner-amp-SinkProcessor-amp-SinkSelector"><a href="#Sink-amp-SinkRunner-amp-SinkProcessor-amp-SinkSelector" class="headerlink" title="Sink&amp;SinkRunner&amp;SinkProcessor&amp;SinkSelector"></a>Sink&amp;SinkRunner&amp;SinkProcessor&amp;SinkSelector</h5><p>flume启动分析过了SinkRunner可能对应一个sink也可能对应一个sinkgroup。因为如果配置文件中有sinkgroup则这个sinkgroup对应的sink会组成一个group然后封装为一个sinkRunner，然后不在sinkgroup中的sink会自己成为一个sinkRunner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SinkRunner</div><div class="line">    SinkProcessor</div><div class="line">        sinks</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class SinkRunner implements LifecycleAware &#123;</div><div class="line">  ...</div><div class="line">  private CounterGroup counterGroup;</div><div class="line">  private PollingRunner runner;</div><div class="line">  private Thread runnerThread;</div><div class="line">  private LifecycleState lifecycleState;</div><div class="line"></div><div class="line">  private SinkProcessor policy;</div><div class="line">  ...</div><div class="line">  @Override</div><div class="line">  public void start() &#123;</div><div class="line">    SinkProcessor policy = getPolicy();</div><div class="line"></div><div class="line">    policy.start();</div><div class="line"></div><div class="line">    runner = new PollingRunner();</div><div class="line"></div><div class="line">    runner.policy = policy;</div><div class="line">    runner.counterGroup = counterGroup;</div><div class="line">    runner.shouldStop = new AtomicBoolean();</div><div class="line"></div><div class="line">    runnerThread = new Thread(runner);</div><div class="line">    runnerThread.setName(&quot;SinkRunner-PollingRunner-&quot; +</div><div class="line">        policy.getClass().getSimpleName());</div><div class="line">    runnerThread.start();</div><div class="line"></div><div class="line">    lifecycleState = LifecycleState.START;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line"></div><div class="line">  public static class PollingRunner implements Runnable &#123;</div><div class="line">    ...</div><div class="line">    private SinkProcessor policy;</div><div class="line">    private AtomicBoolean shouldStop;</div><div class="line">    private CounterGroup counterGroup;</div><div class="line">    ...</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      ...</div><div class="line">      while (!shouldStop.get()) &#123;</div><div class="line">        if (policy.process().equals(Sink.Status.BACKOFF)) &#123;</div><div class="line">            counterGroup.incrementAndGet(&quot;runner.backoffs&quot;);</div><div class="line">            Thread.sleep(Math.min(</div><div class="line">                counterGroup.incrementAndGet(&quot;runner.backoffs.consecutive&quot;)</div><div class="line">                * backoffSleepIncrement, maxBackoffSleep));</div><div class="line">        &#125; else &#123;</div><div class="line">            counterGroup.set(&quot;runner.backoffs.consecutive&quot;, 0L);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>SinkRunner的start方法逻辑和PollableSourceRunner.start类似：</p><ol><li>调用SinkProcessor的start方法</li><li>启动一个线程runnerThread去轮询SinkProcessor的process方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSinkProcessor</span> <span class="keyword">implements</span> <span class="title">SinkProcessor</span>, <span class="title">ConfigurableComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Sink sink;</div><div class="line">  <span class="keyword">private</span> LifecycleState lifecycleState;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    Preconditions.checkNotNull(sink, <span class="string">"DefaultSinkProcessor sink not set"</span>);</div><div class="line">    sink.start();</div><div class="line">    lifecycleState = LifecycleState.START;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</div><div class="line">    <span class="keyword">return</span> sink.process();</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>没有sinkgroup的情况对应DefaultSinkProcessor，DefaultSinkProcessor的process直接调用sink.process<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DefaultSinkProcessor</div><div class="line">LoadBalancingSinkProcessor</div><div class="line">    RoundRobinSinkSelector </div><div class="line">    RandomOrderSinkSelector</div><div class="line">FailoverSinkProcessor</div></pre></td></tr></table></figure></p><h5 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h5><p>channel的启动也是调用start方法，具体channel的事务实现单独分析…</p>]]></content>
    
    <summary type="html">
    
      Source&amp;SourceRunner&amp;ChannelProcessor&amp;ChannelSelector
flume的source分为两种
12

public interface PollableSource extends Source    //有process()方法来处理。系统自动调用process()public interface EventDrivenSource extends Source //没有process()方法，而是通过start()来执行向channel中发送送数据的操作。



前面的flume启动过程已经分析过了，在调用AbstractConfigurati
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="flume-ng" scheme="https://xiaofeng613n.github.io/tags/flume-ng/"/>
    
  </entry>
  
  <entry>
    <title>flume源码-启动</title>
    <link href="https://xiaofeng613n.github.io/2018/03/23/20180323flume%E6%BA%90%E7%A0%81-%E5%90%AF%E5%8A%A8/"/>
    <id>https://xiaofeng613n.github.io/2018/03/23/20180323flume源码-启动/</id>
    <published>2018-03-23T13:21:40.000Z</published>
    <updated>2018-03-25T10:21:06.948Z</updated>
    
    <content type="html"><![CDATA[<p>flume的启动是从Application.main开始的，这里先忽略flume配置文件的加载读取（假设已经读取配置），从最简单的启动方式来看一下flume的启动流程</p><p>Application.java 31行<br>application.handleConfigurationEvent(configurationProvider.getConfiguration());</p><p>AbstractConfigurationProvider：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MaterializedConfiguration <span class="title">getConfiguration</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    loadChannels(agentConf, channelComponentMap);</div><div class="line">    loadSources(agentConf, channelComponentMap, sourceRunnerMap);</div><div class="line">    loadSinks(agentConf, channelComponentMap, sinkRunnerMap);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>getConfiguration这个方法的主要功能是物化配置</p><p>接下来分别分析下这三个加载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadChannels</span><span class="params">(AgentConfiguration agentConf, Map&lt;String, ChannelComponent&gt; channelComponentMap)</span> <span class="keyword">throws</span> InstantiationException</span>&#123;</div><div class="line">    ...</div><div class="line">    Channel channel = getOrCreateChannel(...);</div><div class="line">    channelComponentMap.put(chName, <span class="keyword">new</span> ChannelComponent(channel));</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>channel生成后，使用了一个ChannelComponent对象来包装它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadSources</span><span class="params">(AgentConfiguration agentConf, Map&lt;String, ChannelComponent&gt; channelComponentMap, Map&lt;String, SourceRunner&gt; sourceRunnerMap)</span> <span class="keyword">throws</span> InstantiationException </span>&#123;</div><div class="line">    ...</div><div class="line">    Source source = sourceFactory.create(...)</div><div class="line">    ChannelSelector selector = ChannelSelectorFactory.create(sourceChannels, selectorConfig);</div><div class="line">    ChannelProcessor channelProcessor = <span class="keyword">new</span> ChannelProcessor(selector);</div><div class="line">    source.setChannelProcessor(channelProcessor);</div><div class="line">    sourceRunnerMap.put(sourceName, SourceRunner.forSource(source));</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>SourceRunner结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SourceRunner    </div><div class="line">    Source</div><div class="line">        ChannelProcessor</div><div class="line">            ChannelSelector</div><div class="line">                channels    </div><div class="line">        InterceptorChain</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadSinks</span><span class="params">(AgentConfiguration agentConf, Map&lt;String, ChannelComponent&gt; channelComponentMap, Map&lt;String, SinkRunner&gt; sinkRunnerMap)</span> <span class="keyword">throws</span> InstantiationException </span>&#123;</div><div class="line">    ...</div><div class="line">    Sink sink = sinkFactory.create(...)</div><div class="line">    sink.setChannel(channelComponent.channel);</div><div class="line">    sinks.put(sinkName, sink);</div><div class="line">    loadSinkGroups(agentConf, sinks, sinkRunnerMap);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadSinkGroups</span><span class="params">(AgentConfiguration agentConf, Map&lt;String, Sink&gt; sinks, Map&lt;String, SinkRunner&gt; sinkRunnerMap)</span> <span class="keyword">throws</span> InstantiationException </span>&#123;</div><div class="line">    ...</div><div class="line">    SinkGroup group = <span class="keyword">new</span> SinkGroup(groupSinks);</div><div class="line">    sinkRunnerMap.put(comp.getComponentName(),<span class="keyword">new</span> SinkRunner(group.getProcessor()));</div><div class="line">    ...</div><div class="line">    </div><div class="line">    ...</div><div class="line">    SinkProcessor pr = <span class="keyword">new</span> DefaultSinkProcessor();</div><div class="line">    List&lt;Sink&gt; sinkMap = <span class="keyword">new</span> ArrayList&lt;Sink&gt;();</div><div class="line">    sinkMap.add(entry.getValue());</div><div class="line">    pr.setSinks(sinkMap);</div><div class="line">    Configurables.configure(pr, <span class="keyword">new</span> Context());</div><div class="line">    sinkRunnerMap.put(entry.getKey(), <span class="keyword">new</span> SinkRunner(pr));</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>SinkRunner结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SinkGroup</div><div class="line">    sinks</div><div class="line">    SinkProcessor</div><div class="line">SinkRunner</div><div class="line">    SinkProcessor</div><div class="line">        SinkSelector</div><div class="line">        sinks</div></pre></td></tr></table></figure><p>SinkRunner可能对应一个sink也可能对应一个sinkgroup。因为如果配置文件中有sinkgroup则这个sinkgroup对应的sink会组成一个group然后封装为一个sinkRunner，然后不在sinkgroup中的sink会自己成为一个sinkRunner</p><p>物化配置完成后，启动容器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">handleConfigurationEvent</span><span class="params">(MaterializedConfiguration conf)</span> </span>&#123;</div><div class="line">    stopAllComponents();</div><div class="line">    startAllComponents(conf);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAllComponents</span><span class="params">(MaterializedConfiguration materializedConfiguration)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (Entry&lt;String, Channel&gt; entry : materializedConfiguration.getChannels().entrySet()) &#123;</div><div class="line">        ...</div><div class="line">        supervisor.supervise(entry.getValue(), <span class="keyword">new</span> SupervisorPolicy.AlwaysRestartPolicy(), LifecycleState.START);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">     <span class="comment">/*</span></div><div class="line"><span class="comment">     * Wait for all channels to start.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (Entry&lt;String, SinkRunner&gt; entry : materializedConfiguration.getSinkRunners().entrySet()) &#123;</div><div class="line">        ...</div><div class="line">        supervisor.supervise(entry.getValue(), <span class="keyword">new</span> SupervisorPolicy.AlwaysRestartPolicy(), LifecycleState.START);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;String, SourceRunner&gt; entry : materializedConfiguration.getSourceRunners().entrySet()) &#123;</div><div class="line">        ...</div><div class="line">        supervisor.supervise(entry.getValue(), <span class="keyword">new</span> SupervisorPolicy.AlwaysRestartPolicy(), LifecycleState.START);</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    ...   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>stopAllComponents()方法会依次stop各个组件的运行，顺序是：source、sink、channel。之所以有顺序是因为：一、source是不停的读数据放入channel的；二、sink是不停的从channel拿数据的，channel两头都在使用应该最后停止，停止向channel发送数据后sink停止才不会丢数据。stop是通过supervisor.unsupervise方法来完成的。<br>startAllComponents(conf)是启动各个组件的，顺序正好和stopAllComponents()停止顺序相反<br>在startAllComponents中可以看到3个主要的循环都执行supervisor.supervise(…)<br>这是在向LifecycleSupervisor中注册Supervisee（LifecycleAware ）<br>启动channel组件后需要等待一定时间，是为了让所有channel全部启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">supervise</span><span class="params">(LifecycleAware lifecycleAware, SupervisorPolicy policy, LifecycleState desiredState)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    Supervisoree process = <span class="keyword">new</span> Supervisoree();</div><div class="line">    process.status = <span class="keyword">new</span> Status();</div><div class="line">    process.policy = policy;</div><div class="line">    process.status.desiredState = desiredState;</div><div class="line">    process.status.error = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    MonitorRunnable monitorRunnable = <span class="keyword">new</span> MonitorRunnable();</div><div class="line">    monitorRunnable.lifecycleAware = lifecycleAware;</div><div class="line">    monitorRunnable.supervisoree = process;</div><div class="line">    monitorRunnable.monitorService = monitorService;</div><div class="line"></div><div class="line">    supervisedProcesses.put(lifecycleAware, process);</div><div class="line"></div><div class="line">    ScheduledFuture&lt;?&gt; future = monitorService.scheduleWithFixedDelay(monitorRunnable, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div><div class="line">    monitorFutures.put(lifecycleAware, future);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>monitorService定时执行MonitorRunnable，这个Runnable实现主要的逻辑就是，如果lifecycleAware的状态（supervisoree.status.desiredState）不是期望的状态就执行lifecycleAware的start或者stop方法</p><p>（MonitorRunnable保存的lifecycleAware就是前面加载的Channel，SourceRunner,SinkRunner）</p>]]></content>
    
    <summary type="html">
    
      flume的启动是从Application.main开始的，这里先忽略flume配置文件的加载读取（假设已经读取配置），从最简单的启动方式来看一下flume的启动流程

Application.java 31行
application.handleConfigurationEvent(configurationProvider.getConfiguration());

AbstractConfigurationProvider：
1234567

public MaterializedConfiguration getConfiguration() {    ...    loadChann
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="flume-ng" scheme="https://xiaofeng613n.github.io/tags/flume-ng/"/>
    
  </entry>
  
  <entry>
    <title>HBase配置</title>
    <link href="https://xiaofeng613n.github.io/2018/01/14/HBase%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiaofeng613n.github.io/2018/01/14/HBase配置/</id>
    <published>2018-01-13T16:32:20.000Z</published>
    <updated>2018-01-13T17:10:13.063Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环境</strong><br>linux:centos7<br>java:1.8</p><p>SSH设置和密钥生成<br>SSH设置需要在集群上执行不同的操作，如启动，停止和分布式守护shell操作。进行身份验证不同的Hadoop用户，需要一种用于Hadoop的用户提供的公钥/私钥对，并用不同的用户共享。<br>以下的命令被用于生成使用SSH密钥值对。复制公钥从id_rsa.pub为authorized_keys，并提供所有者，读写权限到authorized_keys文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ssh-keygen -t rsa</div><div class="line"># cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</div><div class="line"># chmod 0600 ~/.ssh/</div><div class="line">//验证</div><div class="line"># ssh localhost</div></pre></td></tr></table></figure><h5 id="伪分布式模式"><a href="#伪分布式模式" class="headerlink" title="伪分布式模式"></a>伪分布式模式</h5><h6 id="下载Hbase"><a href="#下载Hbase" class="headerlink" title="下载Hbase"></a>下载Hbase</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># wget http://mirrors.sonic.net/apache/hbase/1.4.0/hbase-1.4.0-bin.tar.gz</div><div class="line"># tar -zxvf hbase-1.4.0-bin.tar.gz</div></pre></td></tr></table></figure><h6 id="配置-HBASE-HOME-conf-hbase-env-sh"><a href="#配置-HBASE-HOME-conf-hbase-env-sh" class="headerlink" title="配置 $HBASE_HOME/conf/hbase-env.sh"></a>配置 $HBASE_HOME/conf/hbase-env.sh</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/usr/java/jdk1.8.0_144/</div><div class="line">export HBASE_MANAGES_ZK=true</div></pre></td></tr></table></figure><h6 id="配置-HBASE-HOME-conf-hbase-site-xml（这里hbase-rootdir使用的是文件系统，非hdfs）"><a href="#配置-HBASE-HOME-conf-hbase-site-xml（这里hbase-rootdir使用的是文件系统，非hdfs）" class="headerlink" title="配置 $HBASE_HOME/conf/hbase-site.xml（这里hbase.rootdir使用的是文件系统，非hdfs）"></a>配置 $HBASE_HOME/conf/hbase-site.xml（这里hbase.rootdir使用的是文件系统，非hdfs）</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hbase.rootdir&lt;/name&gt;</div><div class="line">    &lt;value&gt;file:/usr/local/soft/hbase-1.4.0/h-data&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hbase.master.port&lt;/name&gt;</div><div class="line">    &lt;value&gt;16000&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hbase.master.info.port&lt;/name&gt;</div><div class="line">    &lt;value&gt;16010&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hbase.regionserver.port&lt;/name&gt;</div><div class="line">    &lt;value&gt;16201&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hbase.regionserver.info.port&lt;/name&gt;</div><div class="line">    &lt;value&gt;16301&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property&gt;</div><div class="line">    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</div><div class="line">    &lt;value&gt;true&lt;/value&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure><h6 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># cd $HBASE_HOME/bin </div><div class="line"># sh start-hbase.sh</div><div class="line"># sh stop-hbase.sh</div><div class="line">// 启动后可以使用jps命令看到如下进程</div><div class="line"># jps</div><div class="line">27442 HQuorumPeer</div><div class="line">27668 Jps</div><div class="line">27509 HMaster</div><div class="line">27593 HRegionServer</div></pre></td></tr></table></figure><h6 id="hbase的web页面（机器的域名是linu1）"><a href="#hbase的web页面（机器的域名是linu1）" class="headerlink" title="hbase的web页面（机器的域名是linu1）"></a>hbase的web页面（机器的域名是linu1）</h6><p><a href="http://linux1:16010/master-status" target="_blank" rel="external">http://linux1:16010/master-status</a></p><p><strong>注意</strong><br>windows环境下用java api 连接hbase可能碰到的问题：</p><ol><li>window配置host：<br>ip linux1 </li><li>linux配置host(是的，linux也要配置，应为我们启动的是伪分布式集群):<br>ip linux1</li><li>winutils.exe</li></ol>]]></content>
    
    <summary type="html">
    
      HBase伪集群模式配置与注意事项
    
    </summary>
    
      <category term="大数据" scheme="https://xiaofeng613n.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hbase" scheme="https://xiaofeng613n.github.io/tags/hbase/"/>
    
  </entry>
  
  <entry>
    <title>flume安装与配置</title>
    <link href="https://xiaofeng613n.github.io/2017/10/15/20171015flume%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://xiaofeng613n.github.io/2017/10/15/20171015flume安装与配置/</id>
    <published>2017-10-15T13:35:49.000Z</published>
    <updated>2018-05-17T13:13:15.457Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环境</strong><br>linux:centos7<br>flume:1.7<br>kafka:kafka_2.10-0.10.1.0(已安装好，<a href="http://" target="_blank" rel="external">kafka安装</a>)</p><h6 id="1-下载flume，解压"><a href="#1-下载flume，解压" class="headerlink" title="1.下载flume，解压"></a>1.下载flume，解压</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># pwd</div><div class="line">/usr/local/soft/apache-flume-1.7.0-bin</div><div class="line"># ls</div><div class="line">bin  CHANGELOG  conf  DEVNOTES  doap_Flume.rdf  docs  lib  LICENSE  NOTICE  README.md  RELEASE-NOTES  tools</div></pre></td></tr></table></figure><h6 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h6><p>在conf目录根据模板配置文件flume-conf.properties.template配置agent和collect<br>这里在一台机器上配置了3个agent和1个collect,如下：  </p><p>agent1.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">agent1.sources = s1</div><div class="line">agent1.channels = c1</div><div class="line">agent1.sinks = k1</div><div class="line"></div><div class="line">agent1.sources.s1.type=exec</div><div class="line">agent1.sources.s1.command=tail -F /usr/local/soft/log/a.log</div><div class="line">agent1.sources.s1.channels=c1</div><div class="line">agent1.channels.c1.type=memory</div><div class="line">agent1.channels.c1.capacity=10000</div><div class="line">agent1.channels.c1.transactionCapacity=100</div><div class="line">#设置接收器</div><div class="line">agent1.sinks.k1.channel=c1</div><div class="line">agent1.sinks.k1.type= avro</div><div class="line">agent1.sinks.k1.hostname=192.168.1.108</div><div class="line">agent1.sinks.k1.port=40041</div></pre></td></tr></table></figure></p><p>agent2.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">agent2.sources = s1</div><div class="line">agent2.channels = c1</div><div class="line">agent2.sinks = k1</div><div class="line"></div><div class="line">agent2.sources.s1.type=exec</div><div class="line">agent2.sources.s1.command=tail -F /usr/local/soft/log/b.log</div><div class="line">agent2.sources.s1.channels=c1</div><div class="line">agent2.channels.c1.type=memory</div><div class="line">agent2.channels.c1.capacity=10000</div><div class="line">agent2.channels.c1.transactionCapacity=100</div><div class="line">#设置接收器</div><div class="line">agent2.sinks.k1.channel=c1</div><div class="line">agent2.sinks.k1.type= avro</div><div class="line">agent2.sinks.k1.hostname=192.168.1.108</div><div class="line">agent2.sinks.k1.port=40041</div></pre></td></tr></table></figure></p><p>agent3.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">agent3.sources = s1</div><div class="line">agent3.channels = c1</div><div class="line">agent3.sinks = k1</div><div class="line"></div><div class="line">agent3.sources.s1.type=exec</div><div class="line">agent3.sources.s1.command=tail -F /usr/local/soft/log/c.log</div><div class="line">agent3.sources.s1.channels=c1</div><div class="line">agent3.channels.c1.type=memory</div><div class="line">agent3.channels.c1.capacity=10000</div><div class="line">agent3.channels.c1.transactionCapacity=100</div><div class="line">#设置接收器</div><div class="line">agent3.sinks.k1.channel=c1</div><div class="line">agent3.sinks.k1.type= avro</div><div class="line">agent3.sinks.k1.hostname=192.168.1.108</div><div class="line">agent3.sinks.k1.port=40041</div></pre></td></tr></table></figure></p><p>collect.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">agentx.sources = s1</div><div class="line">agentx.channels = c1</div><div class="line">agentx.sinks = k1</div><div class="line"></div><div class="line">agentx.sources.s1.channels = c1</div><div class="line">agentx.sources.s1.type = avro</div><div class="line">agentx.sources.s1.bind = 192.168.1.108</div><div class="line">agentx.sources.s1.port = 40041</div><div class="line">agentx.sources.s1.threads = 2</div><div class="line"></div><div class="line">agentx.channels.c1.type=memory</div><div class="line">agentx.channels.c1.capacity=10000</div><div class="line">agentx.channels.c1.transactionCapacity=100</div><div class="line"></div><div class="line">#设置kafka接收器</div><div class="line">agentx.sinks.k1.type= org.apache.flume.sink.kafka.KafkaSink</div><div class="line">#设置Kafka的broker地址和端口号</div><div class="line">agentx.sinks.k1.brokerList=192.168.1.108:9093</div><div class="line">#设置Kafka的Topic</div><div class="line">agentx.sinks.k1.topic=topicOfFlume</div><div class="line">#设置序列化方式</div><div class="line">agentx.sinks.k1.serializer.class=kafka.serializer.StringEncoder</div><div class="line"></div><div class="line">agentx.sinks.k1.channel=c1</div></pre></td></tr></table></figure></p><p>可以看出3个agent的配置基本相同，就是sources监听文件不一样</p><h6 id="3-启动"><a href="#3-启动" class="headerlink" title="3.启动"></a>3.启动</h6><p>（注意：-n 后的参数要和配置文件中的agent名相同）<br>在flume目录下执行如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># bin/flume-ng agent --conf ./conf/ -f conf/collect.properties -Dflume.root.logger=DEBUG,console -n agentx</div><div class="line"># bin/flume-ng agent --conf ./conf/ -f conf/agent1.properties -Dflume.root.logger=DEBUG,console -n agent1</div><div class="line"># bin/flume-ng agent --conf ./conf/ -f conf/agent2.properties -Dflume.root.logger=DEBUG,console -n agent2</div><div class="line"># bin/flume-ng agent --conf ./conf/ -f conf/agent3.properties -Dflume.root.logger=DEBUG,console -n agent3</div></pre></td></tr></table></figure></p><p>启动是否成功可以查看（这是在一台机器上部署的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># jps | grep App*</div><div class="line">26160 Application</div><div class="line">41320 Application</div><div class="line">26266 Application</div><div class="line">26205 Application</div></pre></td></tr></table></figure></p><h6 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h6><p>手动或脚本向监听的文件添加内容，kafka中会有数据写入,测试消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaTest</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span>&#123;</div><div class="line">testConsumer();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsumer</span><span class="params">()</span></span>&#123;</div><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.1.108:9093"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"groupC"</span>);</div><div class="line"><span class="comment">//props.put("enable.auto.commit", "true");</span></div><div class="line"><span class="comment">//props.put("auto.commit.interval.ms", "1000");</span></div><div class="line">props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</div><div class="line">consumer.subscribe(Arrays.asList(<span class="string">"topicOfFlume"</span>));</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line"><span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)&#123;</div><div class="line">System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      环境
linux:centos7
flume:1.7
kafka:kafka_2.10-0.10.1.0(已安装好，kafka安装)

1.下载flume，解压
1234

# pwd/usr/local/soft/apache-flume-1.7.0-bin# lsbin  CHANGELOG  conf  DEVNOTES  doap_Flume.rdf  docs  lib  LICENSE  NOTICE  README.md  RELEASE-NOTES  tools

2.配置
在conf目录根据模板配置文件flume-conf.properties.template配置agent
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="flume-ng" scheme="https://xiaofeng613n.github.io/tags/flume-ng/"/>
    
  </entry>
  
  <entry>
    <title>my first post</title>
    <link href="https://xiaofeng613n.github.io/2017/10/03/my-first-post/"/>
    <id>https://xiaofeng613n.github.io/2017/10/03/my-first-post/</id>
    <published>2017-10-03T07:31:18.000Z</published>
    <updated>2017-10-03T09:40:43.401Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="aop" scheme="https://xiaofeng613n.github.io/tags/aop/"/>
    
      <category term="ioc" scheme="https://xiaofeng613n.github.io/tags/ioc/"/>
    
  </entry>
  
  <entry>
    <title>my first post</title>
    <link href="https://xiaofeng613n.github.io/2017/10/03/my-first-post2/"/>
    <id>https://xiaofeng613n.github.io/2017/10/03/my-first-post2/</id>
    <published>2017-10-03T07:31:18.000Z</published>
    <updated>2017-10-03T09:40:43.401Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java" scheme="https://xiaofeng613n.github.io/categories/java/"/>
    
    
      <category term="aop" scheme="https://xiaofeng613n.github.io/tags/aop/"/>
    
      <category term="ioc" scheme="https://xiaofeng613n.github.io/tags/ioc/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://xiaofeng613n.github.io/2017/10/03/hello-world/"/>
    <id>https://xiaofeng613n.github.io/2017/10/03/hello-world/</id>
    <published>2017-10-03T05:05:40.250Z</published>
    <updated>2018-01-13T17:26:32.516Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p><p><strong>使用问题</strong><br>本地默认端口被占用导致无法访问<br>window:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">netstat -aon|findstr &quot;4000&quot;  // 得到占用端口进程的pid</div><div class="line">tasklist|findstr &quot;884&quot; //根据pid查看具体应用</div><div class="line">taskkill /f /t /im FoxitProtect.exe  //结束应用</div></pre></td></tr></table></figure></p><p>linux:<br>netstat -anp | grep 端口号或者netstat-tunlp查找，然后kill即可</p>]]></content>
    
    <summary type="html">
    
      Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.

Quick Start
Create a new post
1

$ hexo new &quot;My New Post&quot;

More info: Writing

Run server
1

$ hexo serv
    
    </summary>
    
    
  </entry>
  
</feed>
